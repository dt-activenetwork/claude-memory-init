# Heavyweight Plugins

Design document for the Heavyweight Plugin Framework in claude-init v2.2+.

**Version**: 2.2.0-alpha
**Last Updated**: 2025-11-26
**Status**: Implemented

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Plugin Interface](#plugin-interface)
4. [Merge Strategies](#merge-strategies)
5. [Creating a Heavyweight Plugin](#creating-a-heavyweight-plugin)
6. [Built-in Heavyweight Plugins](#built-in-heavyweight-plugins)
7. [Best Practices](#best-practices)
8. [Troubleshooting](#troubleshooting)

---

## Overview

### What is a Heavyweight Plugin?

A heavyweight plugin is a plugin that has its own initialization command (typically an external CLI tool) that generates files which may conflict with files generated by claude-init or other plugins.

**Examples:**
- `claude-flow`: Runs `pnpm dlx claude-flow@alpha init` to set up orchestration infrastructure
- External AI tools with their own scaffolding commands

### Why Heavyweight Plugins?

Some external tools:
1. Have their own initialization commands that create project structures
2. Generate configuration files (like CLAUDE.md) that overlap with our generated files
3. Need to integrate seamlessly without losing user customizations

The heavyweight plugin framework solves these challenges by:
- Backing up protected files before running external commands
- Merging conflicting content using configurable strategies
- Restoring backups if initialization fails

### Lightweight vs Heavyweight Plugins

| Aspect | Lightweight Plugins | Heavyweight Plugins |
|--------|--------------------|--------------------|
| Init Command | None | External command |
| File Generation | Direct write | May conflict with existing files |
| Execution Order | First | After all lightweight plugins |
| File Protection | Not needed | Automatic backup and merge |
| Error Recovery | Standard | Full rollback support |
| `meta.heavyweight` | `false` or undefined | `true` |

---

## Architecture

### HeavyweightPluginManager

The `HeavyweightPluginManager` class handles the complex lifecycle of heavyweight plugins:

```
┌─────────────────────────────────────────────────────────────────┐
│                    Heavyweight Plugin Flow                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   1. Get Config          2. Backup Files       3. Execute Cmd    │
│   ┌─────────────┐        ┌─────────────┐       ┌─────────────┐  │
│   │ getHeavy-   │  ───►  │   Backup    │  ───► │    Spawn    │  │
│   │ weightConfig│        │  Protected  │       │   Init Cmd  │  │
│   └─────────────┘        │    Files    │       └─────────────┘  │
│                          └─────────────┘              │          │
│                                                       ▼          │
│   6. Cleanup             5. Write Merged       4. Merge Files    │
│   ┌─────────────┐        ┌─────────────┐       ┌─────────────┐  │
│   │   Remove    │  ◄───  │   Write     │  ◄─── │   Merge     │  │
│   │   Backups   │        │   Result    │       │  Strategy   │  │
│   └─────────────┘        └─────────────┘       └─────────────┘  │
│                                                                  │
│   On Error:              On Error:                               │
│   ┌─────────────┐        ┌─────────────┐                        │
│   │   Restore   │  ◄───  │  Log Error  │                        │
│   │   Backups   │        │   Return    │                        │
│   └─────────────┘        └─────────────┘                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Execution Flow

```typescript
// In InteractiveInitializer.executeInitialization()

// 1. Separate plugins by weight
const { lightweight, heavyweight } = separatePluginsByWeight(allPlugins);

// 2. Execute lightweight plugins first (standard lifecycle)
await lightweightLoader.executeHook('beforeInit', context);
await lightweightLoader.executeHook('execute', context);
await lightweightLoader.executeHook('afterInit', context);

// 3. Write plugin resources (slash commands, skills, data files)
await resourceWriter.writeAllResources(lightweight, pluginConfigs, context);

// 4. Generate AGENT.md (all plugins contribute)
await this.generateAgentMd(...);

// 5. Execute heavyweight plugins last
if (heavyweight.length > 0) {
  await this.executeHeavyweightPlugins(heavyweight, context, targetDir);
}
```

### File Protection and Merge Mechanism

```
Before Init Command:
┌────────────────────────────────────────────────────────────┐
│ Project Root                                               │
├────────────────────────────────────────────────────────────┤
│ CLAUDE.md ─────────────┬──────► Backup to .agent/tmp/      │
│                        │        heavyweight-backup/        │
│ .agent/config.toon ────┘        CLAUDE.md                  │
│                                 .agent/config.toon         │
└────────────────────────────────────────────────────────────┘

After Init Command:
┌────────────────────────────────────────────────────────────┐
│ Project Root                                               │
├────────────────────────────────────────────────────────────┤
│ CLAUDE.md (plugin's)───┬──────► Merge with backup          │
│                        │        using strategy             │
│ .agent/config.toon ────┘        (append/prepend/custom)    │
│                                                            │
│ Result: Merged file written back to original location      │
└────────────────────────────────────────────────────────────┘
```

---

## Plugin Interface

### PluginMeta Extensions

```typescript
interface PluginMeta {
  // ... existing fields ...

  /**
   * Whether this is a heavyweight plugin
   *
   * Heavyweight plugins have their own initialization commands that generate
   * files which may conflict with our generated files. They require special
   * handling for file protection and merging.
   */
  heavyweight?: boolean;

  /**
   * Names of plugins that conflict with this plugin
   *
   * When a conflicting plugin is selected, this plugin will be disabled
   * in the plugin selection UI.
   */
  conflicts?: string[];
}
```

### HeavyweightPluginConfig

```typescript
/**
 * Configuration returned by getHeavyweightConfig()
 */
interface HeavyweightPluginConfig {
  /**
   * Files to protect during initialization
   * These will be backed up and merged according to their strategy
   */
  protectedFiles: ProtectedFile[];

  /**
   * Initialization command to execute
   * Example: 'pnpm dlx claude-flow@alpha init'
   * Set to null if no command needed
   */
  initCommand: string | null;

  /**
   * Working directory for the init command (optional)
   * Defaults to project root
   */
  workingDirectory?: string;

  /**
   * Timeout for the init command in milliseconds
   * Default: 120000 (2 minutes)
   */
  timeout?: number;

  /**
   * Environment variables to pass to the init command
   */
  env?: Record<string, string>;
}
```

### ProtectedFile

```typescript
/**
 * Protected file configuration
 */
interface ProtectedFile {
  /** Path relative to project root (e.g., 'CLAUDE.md') */
  path: string;

  /** Strategy for merging our content with plugin's content */
  mergeStrategy: MergeStrategy;
}

/**
 * Merge strategies
 * - 'append': Our content + separator + their content
 * - 'prepend': Their content + separator + our content
 * - 'custom': Use plugin's mergeFile() function
 */
type MergeStrategy = 'append' | 'prepend' | 'custom';
```

### Plugin Methods

```typescript
interface Plugin {
  // ... existing methods ...

  /**
   * Get heavyweight plugin configuration
   * Only called if meta.heavyweight is true
   */
  getHeavyweightConfig?: (
    context: PluginContext
  ) => HeavyweightPluginConfig | Promise<HeavyweightPluginConfig>;

  /**
   * Custom file merge function
   * Called when a protected file has mergeStrategy: 'custom'
   */
  mergeFile?: (
    filePath: string,
    ourContent: string | null,
    theirContent: string,
    context: PluginContext
  ) => string | Promise<string>;
}
```

---

## Merge Strategies

### Append Strategy

Our content comes first, followed by the plugin's content.

```
Before Merge:
┌──────────────────────────────┐
│ Our CLAUDE.md                │
│ # Project Instructions       │
│ ...existing content...       │
└──────────────────────────────┘

┌──────────────────────────────┐
│ Their CLAUDE.md              │
│ # Claude Flow                │
│ ...plugin content...         │
└──────────────────────────────┘

After Merge (append):
┌──────────────────────────────┐
│ # Project Instructions       │
│ ...existing content...       │
│                              │
│ ---                          │
│                              │
│ # Claude Flow                │
│ ...plugin content...         │
└──────────────────────────────┘
```

**Use Case**: When your content should take precedence and plugin content is supplementary.

### Prepend Strategy

The plugin's content comes first, followed by our content.

```
After Merge (prepend):
┌──────────────────────────────┐
│ # Claude Flow                │
│ ...plugin content...         │
│                              │
│ ---                          │
│                              │
│ # Project Instructions       │
│ ...existing content...       │
└──────────────────────────────┘
```

**Use Case**: When plugin content should be seen first (e.g., critical setup instructions).

### Custom Strategy

The plugin implements its own merge logic via the `mergeFile()` method.

```typescript
mergeFile: async (filePath, ourContent, theirContent, context) => {
  if (filePath === '.agent/config.toon') {
    // Custom merge: combine configurations intelligently
    return `# Our Configuration
${ourContent}

# Claude Flow Configuration
${theirContent}`;
  }
  // Default fallback
  return `${ourContent}\n\n---\n\n${theirContent}`;
}
```

**Use Case**: Complex merge scenarios like:
- Configuration files that need intelligent merging
- JSON/TOON files that should be deep-merged
- Files with specific section markers

---

## Creating a Heavyweight Plugin

### Step 1: Define Plugin Metadata

```typescript
const myHeavyweightPlugin: Plugin = {
  meta: {
    name: 'my-heavy-plugin',
    commandName: 'heavy',
    version: '1.0.0',
    description: 'My heavyweight plugin',
    heavyweight: true,  // Mark as heavyweight
    conflicts: ['conflicting-plugin'],  // Optional: declare conflicts
  },
  // ...
};
```

### Step 2: Implement Configuration Flow

```typescript
configuration: {
  needsConfiguration: true,

  configure: async (context) => {
    // Interactive configuration
    const mode = await context.ui.radioList(
      'Select initialization mode:',
      [
        { name: 'Standard', value: 'standard' },
        { name: 'Minimal', value: 'minimal' },
        { name: 'Skip', value: 'skip' },
      ],
      'standard'
    );

    if (mode === 'skip') {
      return { enabled: false, options: { mode: 'skip' } };
    }

    return {
      enabled: true,
      options: {
        mode,
        initCommand: `my-tool init --mode=${mode}`,
      },
    };
  },

  getSummary: (config) => {
    if (!config.enabled) return ['Plugin: Skipped'];
    return [`Mode: ${config.options.mode}`];
  },
},
```

### Step 3: Implement getHeavyweightConfig

```typescript
getHeavyweightConfig: async (context) => {
  const config = context.config.plugins.get('my-heavy-plugin');

  if (!config || !config.enabled) {
    return {
      protectedFiles: [],
      initCommand: null,
    };
  }

  return {
    protectedFiles: [
      { path: 'CLAUDE.md', mergeStrategy: 'append' },
      { path: '.agent/config.toon', mergeStrategy: 'custom' },
    ],
    initCommand: config.options.initCommand as string,
    timeout: 120000,  // 2 minutes
    env: {
      MY_VAR: 'value',
    },
  };
},
```

### Step 4: Implement Custom Merge (Optional)

```typescript
mergeFile: async (filePath, ourContent, theirContent, context) => {
  if (filePath === '.agent/config.toon') {
    // Parse and merge TOON configurations
    const ourConfig = parseToon(ourContent || '');
    const theirConfig = parseToon(theirContent);

    return stringifyToon({
      ...ourConfig,
      ...theirConfig,
      // Preserve our project settings
      project: ourConfig.project,
    });
  }

  // Default: append
  return `${ourContent || ''}\n\n---\n\n${theirContent}`;
},
```

### Complete Example

```typescript
import type { Plugin, PluginConfig, PluginContext } from '../plugin/types.js';

export const claudeFlowPlugin: Plugin = {
  meta: {
    name: 'claude-flow',
    commandName: 'flow',
    version: '1.0.0',
    description: 'Claude Flow integration for AI orchestration',
    heavyweight: true,
    conflicts: ['task-system'],
    recommended: false,
  },

  configuration: {
    needsConfiguration: true,

    configure: async (context) => {
      const mode = await context.ui.radioList(
        'Select Claude Flow initialization mode:',
        [
          { name: 'Standard', value: 'standard', description: 'Full setup' },
          { name: 'SPARC', value: 'sparc', description: 'SPARC methodology' },
          { name: 'Minimal', value: 'minimal', description: 'Minimal setup' },
          { name: 'Skip', value: 'skip', description: 'Skip initialization' },
        ],
        'standard'
      );

      if (mode === 'skip') {
        return { enabled: false, options: { mode: 'skip' } };
      }

      const workflows = mode !== 'minimal'
        ? await context.ui.checkboxList(
            'Select workflows:',
            [
              { name: 'Code Review', value: 'code-review', checked: true },
              { name: 'Documentation', value: 'documentation', checked: true },
              { name: 'Testing', value: 'testing', checked: false },
            ]
          )
        : [];

      return {
        enabled: true,
        options: {
          mode,
          workflows,
          initCommand: buildCommand(mode, workflows),
        },
      };
    },

    getSummary: (config) => {
      if (!config.enabled) return ['Claude Flow: Skipped'];
      return [
        `Mode: ${config.options.mode}`,
        `Workflows: ${(config.options.workflows as string[]).join(', ') || 'None'}`,
      ];
    },
  },

  getHeavyweightConfig: async (context) => {
    const config = context.config.plugins.get('claude-flow');

    if (!config || !config.enabled) {
      return { protectedFiles: [], initCommand: null };
    }

    return {
      protectedFiles: [
        { path: 'CLAUDE.md', mergeStrategy: 'append' },
        { path: '.agent/config.toon', mergeStrategy: 'custom' },
      ],
      initCommand: config.options.initCommand as string,
      timeout: 120000,
    };
  },

  mergeFile: async (filePath, ourContent, theirContent, context) => {
    if (filePath === '.agent/config.toon') {
      return `# Original Configuration
${ourContent || '# No original config'}

# Claude Flow Configuration
${theirContent}`;
    }
    return `${ourContent || ''}\n\n---\n\n${theirContent}`;
  },

  prompt: {
    placeholder: 'CLAUDE_FLOW_SECTION',
    generate: async (config, context) => {
      if (!config.enabled) return '';
      return `## Claude Flow

This project uses Claude Flow for AI orchestration.
Mode: ${config.options.mode}
`;
    },
  },
};

function buildCommand(mode: string, workflows: string[]): string {
  const parts = ['pnpm', 'dlx', 'claude-flow@alpha', 'init'];
  if (mode !== 'standard') parts.push(`--mode=${mode}`);
  if (workflows.length > 0) parts.push(`--workflows=${workflows.join(',')}`);
  return parts.join(' ');
}
```

---

## Built-in Heavyweight Plugins

### Claude Flow Plugin

**Purpose**: Integrates Claude Flow for advanced AI orchestration with multi-agent support.

**Configuration Options**:

| Option | Description | Values |
|--------|-------------|--------|
| Mode | Initialization mode | standard, sparc, minimal, skip |
| Workflows | Selected workflows | code-review, documentation, testing, etc. |
| MCP Servers | MCP server configuration | filesystem, memory, github, database |
| Swarm Mode | Enable multi-agent orchestration | true/false |

**Protected Files**:
- `CLAUDE.md` - Merged with append strategy
- `.agent/config.toon` - Merged with custom strategy

**Conflicts**:
- `task-system` - Claude Flow provides its own task management

**Example Command**:
```bash
pnpm dlx claude-flow@alpha init --mode=sparc --workflows=specification,architecture
```

---

## Best Practices

### When to Use Heavyweight Plugins

Use heavyweight plugins when:
- Integrating external tools with their own CLI scaffolding
- The external tool generates files that may conflict with claude-init
- You need automatic backup and recovery for generated files
- Complex merge logic is required for configuration files

Do NOT use heavyweight plugins for:
- Simple file generation (use standard plugins)
- Plugins that don't run external commands
- Plugins that don't generate conflicting files

### File Protection Strategy

1. **Identify Critical Files**: List all files your external command might modify
2. **Choose Merge Strategies**:
   - `append` for documentation/markdown files
   - `prepend` for critical instructions
   - `custom` for structured data (JSON, TOON, YAML)
3. **Test Thoroughly**: Test merge behavior with various existing content

### Error Handling

```typescript
getHeavyweightConfig: async (context) => {
  try {
    const config = context.config.plugins.get('my-plugin');

    if (!config?.enabled) {
      return { protectedFiles: [], initCommand: null };
    }

    // Validate command exists
    const command = config.options.initCommand;
    if (!command || typeof command !== 'string') {
      throw new Error('Init command not configured');
    }

    return {
      protectedFiles: [...],
      initCommand: command,
      timeout: 120000,
    };
  } catch (error) {
    context.logger.warning(`Failed to configure: ${error.message}`);
    return { protectedFiles: [], initCommand: null };
  }
},
```

### Testing Heavyweight Plugins

```typescript
describe('MyHeavyweightPlugin', () => {
  it('should backup files before init command', async () => {
    // Setup
    const plugin = createMyPlugin();
    const manager = new HeavyweightPluginManager(tempDir, mockLogger);

    // Mock file operations
    vi.mocked(fileExists).mockResolvedValue(true);
    vi.mocked(readFile).mockResolvedValue('original content');

    // Execute
    await manager.executeHeavyweightPlugin(plugin, mockContext);

    // Verify backup was created
    expect(copyFile).toHaveBeenCalled();
  });

  it('should restore backups on failure', async () => {
    // Setup command to fail
    vi.mocked(spawn).mockReturnValue(failingProcess);

    await manager.executeHeavyweightPlugin(plugin, mockContext);

    // Verify restore was called
    expect(writeFile).toHaveBeenCalledWith(
      expect.stringContaining('CLAUDE.md'),
      'original content'
    );
  });

  it('should merge with append strategy', async () => {
    // ... test merge behavior
  });
});
```

---

## Troubleshooting

### Common Issues

#### Issue: Init command times out

**Symptom**: Error message "Command timed out after Xms"

**Solution**:
1. Increase timeout in `getHeavyweightConfig`:
   ```typescript
   timeout: 300000, // 5 minutes
   ```
2. Check if the command requires user input (not supported)
3. Verify network connectivity for download commands

#### Issue: Merge produces unexpected results

**Symptom**: Merged file has wrong order or duplicated content

**Solution**:
1. Check merge strategy (`append` vs `prepend`)
2. For complex files, implement `custom` strategy with `mergeFile()`
3. Ensure content trimming is handled correctly

#### Issue: Plugin conflicts not detected

**Symptom**: Two conflicting plugins are both enabled

**Solution**:
1. Add `conflicts` array to plugin metadata:
   ```typescript
   conflicts: ['other-plugin-name']
   ```
2. Conflicts are only detected during plugin selection
3. If manually configuring, check for conflicts in `configure()`

#### Issue: Backups not restored after failure

**Symptom**: Original files lost after command failure

**Solution**:
1. Check `HeavyweightPluginManager.restoreBackups()` is being called
2. Verify backup directory exists: `.agent/tmp/heavyweight-backup/`
3. Check file permissions

### Debug Mode

Enable verbose logging to troubleshoot:

```typescript
// In your plugin
getHeavyweightConfig: async (context) => {
  context.logger.info('Getting heavyweight config...');
  context.logger.info(`Protected files: ${JSON.stringify(protectedFiles)}`);
  context.logger.info(`Init command: ${initCommand}`);
  // ...
},

mergeFile: async (filePath, ourContent, theirContent, context) => {
  context.logger.info(`Merging ${filePath}`);
  context.logger.info(`Our length: ${ourContent?.length || 0}`);
  context.logger.info(`Their length: ${theirContent.length}`);
  // ...
},
```

### Reporting Issues

When reporting issues, include:
1. Plugin name and version
2. Init command being executed
3. Protected files configuration
4. Error messages from console
5. Contents of `.agent/tmp/heavyweight-backup/` (if exists)

---

## Related Documents

- [Plugin Architecture](./PLUGIN_ARCHITECTURE_REFACTOR.md) - Core plugin system design
- [Claude Flow Quick Start](./CLAUDE_FLOW_QUICK_START.md) - Claude Flow integration guide
- [User Guide](./USER_GUIDE.md) - Complete user documentation

---

**Version**: 2.2.0-alpha
**Last Updated**: 2025-11-26
